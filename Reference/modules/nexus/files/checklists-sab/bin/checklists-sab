#!/usr/bin/perl -w
# *** SAB ***
# Copyright Â© 2012 NTT Europe
# All Rights Reserved
# Author: Neale Guy <neale.guy@ntt.eu>
# Prover: Chris Weatherby <chris.weatherby@ntt.eu>

# install-script directives:
#     create-directory      logs owner=nexus mode=775
#     create-directory      checklist_scripts owner=nexus mode=775
#     create-directory      checklist_host_locks owner=nexus mode=775

# The external scripts provided by NetEng require Net::SSH::Expect
# sudo apt-get install curl
# curl -L http://cpanmin.us | perl - --sudo App::cpanminus
# sudo cpanm Net::SSH::Expect
##!!!!!WARNING Net::SSH::Expect can die returning a status of 0 !!!!!!!!!!!!!
use strict;
use Data::Dumper;
use XMLRPC::Transport::HTTP;
use Getopt::Long qw{:config auto_help};
use POSIX ":sys_wait_h";
use FindBin; BEGIN { require "$FindBin::RealBin/../lib/perl/setup-inc.pm" };
use check_list_params qw( $optional  $required $script_config);
use File::Temp qw(tempfile);

use lib '/usr/local/ntte/nexus/checklists-sab/bin/';

our $optional;
our $required;
our $script_config;


$ENV{'HTTP_TRANSFER_ENCODING'} = 'chunked';
@::ISA = qw(XMLRPC::Server::Parameters);

my @required_params = @{$required};

my @optional_params = @{$optional};


my $scriptpath = dirname($0).'/';
my $SCRIPTS_DIR = $scriptpath.'../checklist_scripts';
my $HOSTS_LOCK = $scriptpath.'../checklist_host_locks';
my $LOGS_DIR = $scriptpath.'../logs';
my $SCRIPT_TIMEOUT_SECS = 30;
my $OUR_CHILD_EXIT = 9999;
my $MAX_LOG_SIZE = 1024 * 1024 *1024 * 8;

sub authenticate($;$) {
    my($caller,$params);
    my $ret = 0;

    if(defined $_[0] && $_[0] eq 'main') {
        ($caller,$params) = @_;
    }
    else {
        ($params) = @_;
    }
    my $run_params = validate_script($params);
    $ret = ($run_params)?1:0;

    return ( {
            status=>$ret,
            output=>$run_params,
            script_name=>$params->{script},
            run_token=>'whatever'
            });
}

sub main() {

    if (defined $ENV{REMOTE_ADDR}) {
        XMLRPC::Transport::HTTP::CGI
        -> dispatch_to('run_custom_script',
                       'authenticate',
                       'display_log',
                       'list_custom_scripts')
        -> handle;
    }
    else {
        my %opts;
        my $params;
        my %options;
        my $services = {
                         'run_custom_script'=>\&run_custom_script,
                         'authenticate'=>\&authenticate,
                         'display_log'=>\&display_log,
                         'list_custom_scripts'=>\&list_custom_scripts
                       };

        foreach my $required_param (@required_params,'serviceName') {
            $options{$required_param."=s"} = \$params->{$required_param};
        }

        foreach my $optional_param (@optional_params) {
            $options{$optional_param.":s"} = \$params->{$optional_param};
        }

        if (!@ARGV) {
           die("$0 --serviceName service params ...\n"
               ."Allowed services are :\n\t\t"
               .join("\n\t\t",keys %{$services})
               ."\r\n");
        }

        GetOptions(%options);

        foreach my $param (keys %{$params}){
            delete($params->{$param})
               if (!defined($params->{$param}));
        }

        my $service_name = $params->{'serviceName'} || '';

        if (!length($service_name)||
            !exists($services->{$params->{serviceName}})) {
           die("Unknown service (".$service_name.") \n".
               "Allowed names are:\n\t\t"
                .join("\n\t\t",keys %{$services}));
        }

        my $output = $services->{$params->{'serviceName'}}->($params);
        print Dumper($output)."\r\n";
    }
}

main();
exit();


sub list_custom_scripts {
    unless(-d $SCRIPTS_DIR) {
        return 0;
    }
    my @files = <$SCRIPTS_DIR/*>;
    return (@files);
}

sub run_custom_script {
    my($caller,$params);

    my $status = 2;#System Failure
    my $sab_error  = '';
    my $child_return = undef;
    my $limit;
    my $filename;
    my $emergency_filename;

    my @results;

    if(defined $_[0] && $_[0] eq 'main') {
        ($caller,$params) = @_;
    }
    else {
        ($params) = @_;
    }

    my $run_params;
    my $run_uid;

    # Validate params
    $params = validate_args($params);

    unless(ref $params eq 'HASH') {
        $sab_error =  $params;
        $params = {};
    }

    unless (length($sab_error)) {

        if (exists($params->{'systemName'})) {
           $sab_error = lock_host($params->{'systemName'}
           .'-'.$params->{script});
        }
        else {
           $sab_error = 'System name unavailable - cannot run script';
        }
    }


    unless (length($sab_error)) {

    # Check script exists
       $run_params = validate_script($params);
       unless($run_params) {
          $sab_error  =  "Error script $params->{script} not found";
       };
    }

    unless (length($sab_error)) {

        $run_uid = $params->{run_uid};

        unless($run_uid) {
               $sab_error = "Error no uid given to run script with";
        }
        $filename = run_dir_path($LOGS_DIR,$run_uid);
    }

    #Create temporary error log
    unless($filename) {
        ($emergency_filename ,$filename) = tempfile();
        $emergency_filename  = undef;
    }

    unless (length($sab_error)) {
        $limit = $params->{log_limit};

        # Create a unique filename for the script output

        #my $ip_address = $params->{hostIp};
        #$ip_address =~ s/\.//g;
        #my $filename = '/tmp/'.$params->{script}.'_'.$ip_address.'_'.time();

        if (-e $filename) {
           $sab_error = "Uid for script run not unique on server.";
        }
    }

    if (length($sab_error)) {

    }else
    {
    # Fork to run the third party script in its own process (so we can kill it)
       my $pid = fork();
       if (not defined $pid) {
          print "Error Cannot fork for $params->{script}\n"
                if defined $params->{debug};
          $sab_error = "Internal Error can't launch process "
                        .$params->{script};
       }
       elsif ($pid == 0) {
          #   ($EUID, $EGID) = ($UID, $GID);
          # Child
          # Run the script and exit
           my $script_args = [];
           foreach my $prm (@{$run_params}) {
               push(@{$script_args}, "--".$prm);

               push(@{$script_args},
                    (exists($params->{$prm})?$params->{$prm}:''));
           }

           my $cmd = $SCRIPTS_DIR.'/'.$params->{script};

           run_log($filename.'.run',$script_args);

           my $return = run_cmd($filename,$cmd,$script_args);

           exit($return);
       }

       # Parent
       # Wait for output from the script or kill it if its taking too long
       print "Running $params->{script} and waiting for output.\n"
            if defined $params->{debug};

       for(my $count=0;$count<=$SCRIPT_TIMEOUT_SECS;$count++) {
           if(waitpid(-1, &WNOHANG) != 0) {
              if ($?==$OUR_CHILD_EXIT) {
                  print "Child wrapper gone\n"
                    if defined $params->{debug};
                  next;
              }
              else {
                 $child_return = _reset_ret($?);
              }
              print "$params->{script} $child_return ended ok.\n"
                    if defined $params->{debug};
              last;
           }
           sleep 1;
       }

       # Check and kill any remaining rogue process
       if(waitpid(-1, &WNOHANG) == 0) {
          $sab_error = $params->{script}
              ." froze and was killed there maybe partial output";
          if(kill 0, $pid) {
             print "Killing Rogue Process $pid\n" if defined $params->{debug};
             kill 9, $pid;
          }
       }

    }

    ##Script can override this with 0;; line.
    $status  = $child_return if (defined($child_return));

    #This will write the sab error to log, unless the script has returned okay.
    write_status_to_log($filename,$status,$sab_error);

    #This will populate @results from the log.
    ($status,undef) = dump_log($filename,
                               \@results,
                               $status,
                               $limit,
                               $params->{debug});

    unlock_host($params->{'systemName'}.'-'.$params->{script});

    return(\@results);
}

sub _reset_ret($) {
  my ($ret) = @_;
   $ret = $ret>>8;
     return($ret);
}

sub lock_host($) {
    my ($hostname) = @_;

    my $host_filename = $HOSTS_LOCK.'/'.$hostname;

    my $ret ='';

    if (-e  $host_filename) {
        $ret =  'A test script is already running against this host.';
    }
    else {
       open(JK,">$host_filename");
       print JK $$;
       close(JK);

       if (!-e  $host_filename) {
           $ret = 'Failed to get a run lock for this host';
       }
    }
    return ($ret);
}

sub unlock_host($) {
    my ($hostname) = @_;

    if ($hostname) {
        my $host_filename = $HOSTS_LOCK.'/'.$hostname;

        if (-e  $host_filename) {
            open(JK,"$host_filename");

            my $pid = <JK>;
            close(JK);
            if ($pid eq $$) {
                unlink($host_filename);
            }
        }
    }
}

sub write_status_to_log($$$) {
    my ($filename,$status,$msg) = @_;

    my $last_line;

    open (READER, $filename);
    while(<READER>) {
        if ($_ =~/^\d\;\;/) {
          $last_line = $_;
        }
    }
    close (READER);

    if (!$last_line) {
        open (OUTPUT, '>> '.$filename);
        print OUTPUT "\r\n".$msg;
        print OUTPUT "\r\n".$status.";;\r\n";
        close (OUTPUT);
    }
}

sub display_log($$) {
    my($caller,$params);

    my $status = 0;

    my @results;

    if(defined $_[0] && $_[0] eq 'main') {
        ($caller,$params) = @_;
    }
    else {
        ($params) = @_;
    }

    $params = validate_args($params);

    unless(ref $params eq 'HASH') {
        push (@results,{status => $status,
                       output => $params});
        return (\@results);
    }

    my $run_uid = $params->{run_uid};

    my $limit = $params->{log_limit};

    unless($run_uid) {
        push (@results,{status => $status,
                       output => "Error no uid given to run script with"});
        return (\@results);
    }

    my $filename = run_dir_path($LOGS_DIR,$run_uid);

    ($status,undef) = dump_log($filename,
                               \@results,
                               $status,
                               $limit,
                               $params->{debug});

    return(\@results);
}

sub run_log {
    my ($filename , $params) = @_;
    open(FH,"> $filename");
    print FH Dumper _clean_params($params);
    close(FH);
}

sub _clean_params {
    my ($params) = @_;

    my $cleaned_params = { @{$params} };

    foreach my $param_key (keys %{$cleaned_params}) {
        if ($param_key=~/pass/) {
            $cleaned_params->{$param_key} =
                ('*' x length($cleaned_params->{$param_key}));
        }
    }
    return([map {$_ ,$cleaned_params->{$_} } keys %$cleaned_params] );
}


sub dump_log($$$$$) {
   my ($filename,$results,$status,$limit,$debug) = @_;

   my $cl = $limit||1024;
      $cl *=1024;

    # Open script output file and push to array
    if(-e $filename) {
        open(DATA, $filename) || die "Error cannot open output file $!";
        my $output = '';
        while(<DATA>) {
           # s/\s+$//;
            # Reverse status code since 0 should be success...
            if(m/^(\d);;/) {
                $status = $1;
            }
            else {

            }
            unless(/^\W+$/) {
                if ($cl>0) {
                    $output = $output.$_;
                }
                $cl -= length($_);
            }
        }
        close DATA;

        if ($cl<0) {
            $cl*=-1;
            $output ."\r\n---Truncated by ".$cl." bytes ---\r\n ";
        }

        push(@{$results},{status => $status,
                       output => $output});
    }
    else {
        push(@{$results},{status => 1,
                       output => "Error no output from script"});
        print "Error no output from script\n" if defined $debug;
    }
    return($status,$results);
}

sub run_cmd {
    my ($filename, $cmd, $args) = @_;

    my $params = [$cmd ,@{$args}];
    open (OUTPUT, '> '.$filename) || die "Error cannot open output file $!";
#Should be better ways of doing this
    open (STDERR, ">&OUTPUT")|| die "Re-direction of stderr failed $!";

    my $run_cmd = open (CMD,"-|", @{$params});

    if (!defined($run_cmd)) {
        die ("Error: $!");
    }
    elsif($run_cmd) {
        my $count=0;
        while(<CMD>) {
            chomp $_;
            $count += length($_)+1;
            print OUTPUT $_,"\n"
                    if ($count<$MAX_LOG_SIZE);
        }

        print OUTPUT
            "\n***** SYSTEM LOG FILE LIMIT $MAX_LOG_SIZE REACHED *****\n"
                    if ($count>$MAX_LOG_SIZE);
        close OUTPUT;

    }
    else {
        exit($OUR_CHILD_EXIT);
    }

    my $ret;

    while(waitpid($run_cmd, 0)>0) {
       $ret = _reset_ret($?);
       select(undef, undef, undef, 0.25);
    };

    $ret = _reset_ret($?) unless defined($ret);

    return ($ret);
}

sub validate_script {
    my ($params) = @_;
    my $script = $params->{script};

    unless(-d $SCRIPTS_DIR && $script && length($script)) {
        return undef;
    }
    my $catch_params;
    my $script_params;
    print "Found Directory $SCRIPTS_DIR\n" if defined $params->{debug};
    my @files = <$SCRIPTS_DIR/*>;
    print "Scripts Available:\n" if defined $params->{debug};
    foreach my $file (@files) {
        $file =~ s#.*/##;
        print "\t",$file,"\n" if defined $params->{debug};
        if($file eq $script &&
            -x $SCRIPTS_DIR.'/'.$script) {
            $catch_params = `$SCRIPTS_DIR/$script`;
            $catch_params =~s/^$SCRIPTS_DIR\/$script//g;
            $catch_params =~s/^ //g;
            $catch_params =~s/[\r\n]//g;
            $script_params=[split (/ /,$catch_params)];
        }
    }
    return $script_params;
}

sub validate_args {
    my ($params) = @_;

    unless(-d $SCRIPTS_DIR) {
        print "Error Script path doesn't exist $SCRIPTS_DIR\n"
            if defined $params->{debug};
        return "Error Script path doesn't exist $SCRIPTS_DIR";
    }
    if (!exists($params->{'script'})
        || !($params->{'script'})) {
        return "No script specified";
    }

    foreach my $required_param (@required_params) {
        unless (defined $params->{$required_param}) {
            print "Missing Required Parameter $required_param\n"
                if defined $params->{debug};
            return "Missing Required Parameter $required_param";
        }
    }

#IF THESE VALUES HAVE COME FROM THE NEXUS GUI, they have already been validated
#The scripts should be capable of handling invalid parameters

=begin
    if (exists($params->{hostIp})
           && $params->{hostIp} !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
        print "Error IP address malformed\n" if defined $params->{debug};
        return "Error IP address malformed";
    }
=cut

=begin
    if (exists($params->{defaultGw})
         && $params->{defaultGw} =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
        print "Error Default gateway address malformed\n"
                if defined $params->{debug};
        return "Error Default gateway address malformed";
    }
=cut

    if (exists($params->{'run_uid'})
         && $params->{'run_uid'} !~/^[\d]{1,8}$/) {
        return "Error run_uid not an integer<99999999 ";
    }

    return $params;
}

sub run_dir_path($$) {
    my ($base_path, $run_uid) = @_;

    my $filename = $base_path;

    $run_uid = sprintf("%08d",$run_uid);

    $run_uid =~/(\d\d)(\d\d)(\d\d)(.*)/g;
    my $dir_parts = [$1,$2,$3,$4];

    while(scalar(@{$dir_parts})) {
         if (! -e $filename) {
            mkdir($filename);
         }
         $filename.='/'.shift(@{$dir_parts});
    }
    return($filename);
}